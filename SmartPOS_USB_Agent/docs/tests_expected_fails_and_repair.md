# SmartPOS USB Agent — Ожидаемые точки отказа и план починки по тестам

Документ описывает **5 тестовых направлений** (модули и сценарии), типичные причины падений на Windows (в т.ч. IoT/LTSC), а также детальные шаги локализации и исправлений. Материал предназначен для оперативной диагностики («что делать, если тест покраснел»), обеспечения оффлайн‑устойчивости и выполнения ограничений по pybox/stdlib.

> Формат: все команды и пути приведены для рабочего каталога `C:\AI\Repo\smartpos-knowledge-usb\SmartPOS_USB_Agent`. Markdown — UTF‑8 LF.

---

## Унифицированный способ запуска и сбор артефактов

### PowerShell (рекомендуется)

```powershell
cd C:\AI\Repo\smartpos-knowledge-usb\SmartPOS_USB_Agent
New-Item -Type Directory -Force dist | Out-Null
$env:PYTHONUTF8 = "1"; $env:PYTHONIOENCODING = "utf-8"
python -m pytest -q -rA --maxfail=1 --disable-warnings -o log_cli=true -o log_cli_level=INFO --junitxml "dist\pytest-report.xml"
```

### Точечно (по одному тесту)

```powershell
pytest -q tests\test_sqlite_retention.py
pytest -q tests\test_export_zip_mask.py
pytest -q tests\test_config_and_hot_reload.py
pytest -q tests\test_cli_export_smoke.py
pytest -q tests\test_usb_agent_autotests.py
```

**Артефакты CI:** `dist\pytest-report.xml` (JUnit).  
**Критерий готовности:** код возврата `0`; при флапах — понятные логи (RU/EN), покрытие граничных случаев (пустая БД, битая кодировка имён, отсутствующие пути, перезапуск сервиса без прав).

---

## 1) `tests/test_sqlite_retention.py` — Retention/Rotation SQLite

### Симптомы отказов
- `sqlite3.OperationalError: database is locked`.
- `sqlite3.OperationalError: no such table: …`.
- Подвисания при WAL→CHECKPOINT, VACUUM во время активной записи.
- Расхождения по времени/таймзонам (устаревшие записи не удаляются или удаляются неверно).

### Причины
- Параллельный доступ без `busy_timeout` и без корректного транзакционного паттерна.
- Неинициализированная схема БД (тест стартует «на пустом» файле).
- Агрессивный `VACUUM`/`PRAGMA` во время записи.
- Смешение локального времени и UTC.

### План починки
1. **Соединение:** открывать с `timeout=10.0`, включать `PRAGMA busy_timeout=10000`.  
2. **Схема:** при каждом запуске ретенции вызывать инициализацию схемы: `CREATE TABLE IF NOT EXISTS …`.  
3. **Транзакции:** все операции удаления — в явной транзакции; курсоры — в контекст‑менеджерах.  
4. **Время:** хранить метки **в UTC** (`int(time.time())`), преобразовывать при выводе.  
5. **VACUUM:** выполнять по расписанию/таймеру, а не в каждом вызове; при конкуренции — откладывать.  
6. **Логирование и retry:** при `database is locked` — короткий backoff и повтор 1–2 раза, с понятными сообщениями RU/EN.

### Edge‑cases
- Пустая БД (новый файл) — ретенция не падает, а создаёт схему и корректно завершает работу.
- Коррупция файла — аккуратная ошибка, без утечек дескрипторов; лог с путём к БД.
- Длинные пути — поддержка `\\?\` на вводе (Windows), но без попадания префикса в метаданные/логи.

### Критерий PASS для теста
- Удаляются/оставляются записи в соответствии с правилом `max_rows`/`max_age`, не возникает `locked` и «no such table»; итоговая БД валидна.

---

## 2) `tests/test_export_zip_mask.py` — Экспорт в ZIP (маски/кодировки)

### Симптомы отказов
- Несовпадение масок включения/исключения (попадают «лишние» или «не все» файлы).
- Битая кириллица в именах внутри архива.
- Расхождения разделителей путей (`/` vs `\`) в `arcname`.
- Ошибки на длинных путях (> 260 символов) в Windows.

### Причины
- Использование `os.path` вместо `pathlib` и отсутствие нормализации к POSIX‑пути в `arcname`.
- Кодировка имён по умолчанию (cp1251 артефакты) при чтении файловой системы.
- Неформальные паттерны масок, применённые к абсолютным путям, а не к относительным.

### План починки
1. **Пути:** работать через `pathlib.Path`; для `ZipFile.write()` задавать `arcname=p.relative_to(base).as_posix()` (POSIX‑слеши внутри архива).  
2. **Маски:** применять к **относительным** путям; используем `Path.match()` на `p.relative_to(base).as_posix()` либо `fnmatch.translate` + `re` для сложных кейсов.  
3. **Кодировки:** все операции с именами — в UTF‑8; при чтении/записи файлов — `encoding="utf-8"`.  
4. **Длинные пути:** входные пути при необходимости приводить к форме `\\?\…`; префикс в `arcname` **не** сохранять.  
5. **Логи:** фиксировать базовый каталог, количество отобранных файлов, итоговый размер архива; при исключениях — давать понятные RU/EN сообщения.

### Edge‑cases
- Имя файла с пробелами/кириллицей/символами Юникода выше BMP — архив корректен и извлекается.
- Пустая маска — архив создаётся, но пуст; тест не должен падать.

### Критерий PASS для теста
- Архив создаётся, содержит строго ожидаемый набор файлов, имена в `arcname` — POSIX‑вида, кириллица корректна, операция завершается без исключений.

---

## 3) `tests/test_config_and_hot_reload.py` — Конфиг и горячая перезагрузка

### Симптомы отказов
- Файл в `%ProgramData%` не читается/не существует.
- `json.JSONDecodeError` на «полупустых» файлах (редактор не дописал).
- Хот‑перезагрузка ловит промежуточные состояния, приводит к крашу/неконсистентным данным.
- Ошибки прав при записи API Key.

### Причины
- Отсутствие атомарной записи (сразу пишем в `config.json`).
- Отсутствие дебаунса на вотчере; чтение в момент, когда файл ещё не готов.
- Инициализация каталога `%ProgramData%\SmartPOS\usb_agent\` не выполняется при первом запуске.

### План починки
1. **Атомарная запись:** всегда сначала писать во временный файл `config.json.tmp` и делать `os.replace(tmp, config.json)`.
2. **Дебаунс/поллинг:** при хот‑релоде использовать поллинг с интервалом 1–2 сек и/или игнорировать событие до успешного парсинга; при невалидном JSON оставлять **старую** конфигурацию, писать предупреждение в лог.
3. **Права и инициализация:** при первом запуске программно создавать каталог `%ProgramData%\SmartPOS\usb_agent\` и пустой валидный `config.json`; при ошибках прав — давать понятное RU/EN сообщение и не падать.
4. **Кодировки:** `utf-8` везде; при чтении допускается `errors="replace"` (логи должны фиксировать источник ошибки).

### Edge‑cases
- Конфиг отсутствует — создаётся дефолтный; служба/процесс продолжает работать со стандартными параметрами.
- Конфиг битый — ядро не падает; после следующей успешной записи автоматически подхватывает изменения.

### Критерий PASS для теста
- Разбор валидного JSON проходит; при атомарной перезаписи новый ключ/параметр корректно подхватывается либо устойчиво откладывается до следующей итерации, без исключений.

---

## 4) `tests/test_cli_export_smoke.py` — CLI smoke через BAT

### Симптомы отказов
- Отсутствует `src\python\run_usb_devctl.bat`.
- Ненулевой код возврата без осмысленного вывода.
- `Access is denied` при работе с каталогами временных файлов.
- Зависания при запуске в `PowerShell`/`cmd.exe`.

### Причины
- Тест/проект вызывают Python‑CLI вместо BAT (переход на BAT пропущен).
- Использование `subprocess` с `shell=True` → непредсказуемое поведение в разных оболочках.
- Рабочий каталог/права не подготовлены.

### План починки
1. **Вызывать именно BAT:** тест должен запускать `run_usb_devctl.bat` (Python‑CLI оставить как альтернативу в документации, но не в smoke).  
2. **subprocess без `shell=True`:** формировать список аргументов: `[str(BAT), "--help"]`, таймаут 15–20 сек.  
3. **Изолированный `cwd`:** для smoke использовать `tmp_path`; гарантированно создаётся и доступен.  
4. **Коды возврата и вывод:** допускать код `0` или ненулевой **с осмысленным** RU/EN‑выводом; логи записывать всегда.  
5. **CRLF:** убедиться, что у BAT — CRLF (
); некоторые оболочки чувствительны к окончаниям строк.

### Edge‑cases
- PowerShell парсит `--` как свои параметры — при прямом вызове BAT это не влияет; если запускается `pytest` с PowerShell, использовать одинарную строку или стоп‑парсинг `--%` для самой команды pytest.

### Критерий PASS для теста
- Смоук завершён без зависаний; в выводе присутствуют сигнатуры «SmartPOS/USB/Agent/Help/Usage/Использование/Помощь»; архив при self‑test создаётся.

---

## 5) `src/python/usb_agent_autotests.py` — Scaffold автотестов продукта

### Роль файла
- Содержит **реальные сценарии автотестов**, использующие адаптеры/реестр/пробер из `usb_agent_core.py`.
- Запускается через `pytest` и может работать в режиме standalone smoke.
- На него ссылается отдельный юнит‑тест `tests/test_usb_agent_autotests.py`, который проверяет наличие/подключаемость скелета.

### Охват сценариев (позитивные)
1. **Инвентаризация USB** — режимы: `registry`, `adapters`, `prober`.  
2. **Экспорт в ZIP** — проверка базового экспорта, POSIX‑`arcname`, корректной кириллицы.  
3. **Конфиг + hot‑reload** — атомарная запись, дебаунс/поллинг, устойчивость к «полупустым» JSON.  
4. **SQLite retention/rotation** — удаление старых записей без `locked`/`no such table`.  
5. **CLI self‑test/export** — запуск через `run_usb_devctl.bat` (если присутствует), создание архива.

### Негативные кейсы
- Невалидный JSON конфига (проверка устойчивости и логов).  
- Маска экспорта без совпадений (пустой архив).  
- Повреждённая БД (ожидаемая ошибка без краша процесса).  
- Отсутствие BAT (скип/xfail, но не падение набора).

### Требования к реализации скелета
- **Только stdlib**, без `shell=True`, с таймаутами.  
- RU/EN‑логи с чёткими причинами отказа.  
- Мягкая интеграция: если `usb_agent_core`/функции недоступны — `skip/xfail` с объяснением.

### Размещение и подключение
- Путь: `SmartPOS_USB_Agent/src/python/usb_agent_autotests.py`.  
- Для доступа из теста добавить в `tests/test_usb_agent_autotests.py` в начало:

```python
from pathlib import Path
import sys
ROOT = Path(__file__).resolve().parents[1]
SRC_PY = ROOT / "src" / "python"
if str(SRC_PY) not in sys.path:
    sys.path.insert(0, str(SRC_PY))
# далее: from usb_agent_autotests import <нужные объекты>
```

### Критерий PASS для связки
- `tests/test_usb_agent_autotests.py` проходит «зелёным», а сам скелет успешно исполняет все 5 сценариев (позитив/негатив), с корректной деградацией (`skip/xfail`) при отсутствии ядра/бат‑скрипта.

---

## Приложение A — Рекомендованный `pytest.ini`

```ini
[pytest]
addopts = -q -rA --disable-warnings
log_cli = true
log_cli_level = INFO
testpaths =
    tests
filterwarnings =
    ignore::DeprecationWarning
# Подхватывать и файлы вида *_autotests.py
python_files = test_*.py *_autotests.py
```

---

## Приложение B — Подсказки по оболочкам (PowerShell/cmd)

- В **PowerShell** не используйте переносы `^` и команды `set` — это синтаксис `cmd.exe`.  
- Для длинных команд в PowerShell используйте обратную кавычку `` ` `` или пишите в одну строку.  
- Если PowerShell конфликтует с `--` в параметрах, используйте стоп‑парсинг: `pytest --% <дальше ваши опции>`.

Примеры:

```powershell
# Одна строка
python -m pytest -q -rA --maxfail=1 --disable-warnings -o log_cli=true -o log_cli_level=INFO --junitxml "dist\pytest-report.xml"

# С переносами
python -m pytest -q -rA --maxfail=1 --disable-warnings `
  -o log_cli=true -o log_cli_level=INFO `
  --junitxml "dist\pytest-report.xml"

# Стоп-парсинг
python -m pytest --% -q -rA --maxfail=1 --disable-warnings -o log_cli=true -o log_cli_level=INFO --junitxml=dist\pytest-report.xml
```

---

## Контрольные критерии «готово» (Definition of Done)
- Все 5 направлений тестов «зелёные».  
- В флапах — детальные логи (RU/EN), граничные кейсы покрыты.  
- Нет зависимостей от внешней сети; все операции выполняются stdlib‑средствами.  
- Документ соответствует фактическим путям и командам в репозитории.  
- Артефакты CI: `dist/pytest-report.xml` присутствует, генерируется единым прогоном.
